import { sql } from 'drizzle-orm';
import {
  index,
  jsonb,
  pgTable,
  timestamp,
  varchar,
  text,
  integer,
  decimal,
  boolean,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table - Used for session management
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User storage table - Supports local authentication
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique().notNull(),
  password: varchar("password"), // Hashed password for local auth (nullable for OAuth users)
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;

// Business Profiles - Onboarding data for each user's business
export const businesses = pgTable("businesses", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  businessName: text("business_name").notNull(),
  address: text("address"),
  city: text("city"),
  postcode: text("postcode"),
  country: varchar("country").default("United Kingdom"),
  phone: varchar("phone"),
  email: varchar("email"),
  vatNumber: varchar("vat_number"),
  companyNumber: varchar("company_number"),
  logoUrl: text("logo_url"),
  headerText: text("header_text"),
  footerText: text("footer_text"),
  signatureUrl: text("signature_url"),
  qrCodeUrl: text("qr_code_url"),
  paymentLink: text("payment_link"),
  useAutoGeneratedDesign: boolean("use_auto_generated_design").default(false),
  primaryColor: varchar("primary_color").default("#1e40af"),
  onboardingCompleted: boolean("onboarding_completed").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertBusinessSchema = createInsertSchema(businesses).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertBusiness = z.infer<typeof insertBusinessSchema>;
export type Business = typeof businesses.$inferSelect;

// Subscriptions - Trial and billing information
export const subscriptions = pgTable("subscriptions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
  status: varchar("status", { length: 20 }).notNull().default("trial"), // trial, active, canceled, expired
  trialEndsAt: timestamp("trial_ends_at"),
  currentPeriodStart: timestamp("current_period_start"),
  currentPeriodEnd: timestamp("current_period_end"),
  stripeCustomerId: varchar("stripe_customer_id"),
  stripeSubscriptionId: varchar("stripe_subscription_id"),
  paypalSubscriptionId: varchar("paypal_subscription_id"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertSubscriptionSchema = createInsertSchema(subscriptions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertSubscription = z.infer<typeof insertSubscriptionSchema>;
export type Subscription = typeof subscriptions.$inferSelect;

// Customers - Client/customer records for the business
export const customers = pgTable("customers", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  email: varchar("email"),
  phone: varchar("phone"),
  address: text("address"),
  city: text("city"),
  postcode: text("postcode"),
  country: varchar("country").default("United Kingdom"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertCustomerSchema = createInsertSchema(customers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertCustomer = z.infer<typeof insertCustomerSchema>;
export type Customer = typeof customers.$inferSelect;

// Inventory Items - Products with stock levels and pricing
export const inventoryItems = pgTable("inventory_items", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  description: text("description"),
  sku: varchar("sku"),
  quantity: integer("quantity").notNull().default(0),
  unitPrice: decimal("unit_price", { precision: 10, scale: 2 }).notNull(),
  unit: varchar("unit").default("pcs"), // pcs, kg, lbs, etc
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertInventoryItemSchema = createInsertSchema(inventoryItems).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  unitPrice: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
});

export type InsertInventoryItem = z.infer<typeof insertInventoryItemSchema>;
export type InventoryItem = typeof inventoryItems.$inferSelect;

// Quotations
export const quotations = pgTable("quotations", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  customerId: varchar("customer_id").references(() => customers.id, { onDelete: "set null" }),
  quotationNumber: varchar("quotation_number").notNull(),
  customerName: text("customer_name").notNull(),
  customerEmail: varchar("customer_email"),
  customerAddress: text("customer_address"),
  status: varchar("status", { length: 20 }).default("draft"), // draft, sent, accepted, declined
  items: jsonb("items").notNull(), // Array of {name, description, quantity, unitPrice, total}
  subtotal: decimal("subtotal", { precision: 10, scale: 2 }).notNull(),
  taxRate: decimal("tax_rate", { precision: 5, scale: 2 }).default("20"), // UK VAT 20%
  taxAmount: decimal("tax_amount", { precision: 10, scale: 2 }).notNull(),
  total: decimal("total", { precision: 10, scale: 2 }).notNull(),
  notes: text("notes"),
  validUntil: timestamp("valid_until"),
  includeSignature: boolean("include_signature").default(true),
  includeHeader: boolean("include_header").default(true),
  includeFooter: boolean("include_footer").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertQuotationSchema = createInsertSchema(quotations).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  subtotal: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
  taxRate: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
  taxAmount: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
  total: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
});

export type InsertQuotation = z.infer<typeof insertQuotationSchema>;
export type Quotation = typeof quotations.$inferSelect;

// Invoices
export const invoices = pgTable("invoices", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  customerId: varchar("customer_id").references(() => customers.id, { onDelete: "set null" }),
  invoiceNumber: varchar("invoice_number").notNull(),
  customerName: text("customer_name").notNull(),
  customerEmail: varchar("customer_email"),
  customerAddress: text("customer_address"),
  status: varchar("status", { length: 20 }).default("draft"), // draft, sent, paid, overdue
  items: jsonb("items").notNull(), // Array of {name, description, quantity, unitPrice, total}
  subtotal: decimal("subtotal", { precision: 10, scale: 2 }).notNull(),
  taxRate: decimal("tax_rate", { precision: 5, scale: 2 }).default("20"),
  taxAmount: decimal("tax_amount", { precision: 10, scale: 2 }).notNull(),
  total: decimal("total", { precision: 10, scale: 2 }).notNull(),
  notes: text("notes"),
  dueDate: timestamp("due_date"),
  paidAt: timestamp("paid_at"),
  includeSignature: boolean("include_signature").default(true),
  includeHeader: boolean("include_header").default(true),
  includeFooter: boolean("include_footer").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertInvoiceSchema = createInsertSchema(invoices).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  subtotal: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
  taxRate: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
  taxAmount: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
  total: z.union([z.string(), z.number()]).transform((val) => typeof val === 'number' ? val.toString() : val),
});

export type InsertInvoice = z.infer<typeof insertInvoiceSchema>;
export type Invoice = typeof invoices.$inferSelect;

// Delivery Challans
export const deliveryChallans = pgTable("delivery_challans", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  customerId: varchar("customer_id").references(() => customers.id, { onDelete: "set null" }),
  challanNumber: varchar("challan_number").notNull(),
  customerName: text("customer_name").notNull(),
  customerAddress: text("customer_address"),
  deliveryAddress: text("delivery_address"),
  status: varchar("status", { length: 20 }).default("draft"), // draft, dispatched, delivered
  items: jsonb("items").notNull(), // Array of {name, description, quantity, unit}
  deliveryDate: timestamp("delivery_date"),
  notes: text("notes"),
  includeSignature: boolean("include_signature").default(true),
  includeHeader: boolean("include_header").default(true),
  includeFooter: boolean("include_footer").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertDeliveryChallanSchema = createInsertSchema(deliveryChallans).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertDeliveryChallan = z.infer<typeof insertDeliveryChallanSchema>;
export type DeliveryChallan = typeof deliveryChallans.$inferSelect;

// Employees - HR records
export const employees = pgTable("employees", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  fullName: text("full_name").notNull(),
  email: varchar("email"),
  phone: varchar("phone"),
  position: varchar("position"),
  department: varchar("department"),
  salary: decimal("salary", { precision: 10, scale: 2 }),
  startDate: timestamp("start_date"),
  status: varchar("status", { length: 20 }).default("active"), // active, inactive, terminated
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertEmployeeSchema = createInsertSchema(employees).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertEmployee = z.infer<typeof insertEmployeeSchema>;
export type Employee = typeof employees.$inferSelect;
